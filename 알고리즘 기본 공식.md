## 빅오 속도

O(n!) > O(2^n) > O(n^2) > O(nlogn) > O(n) > O(logn)

### 구간 합

각 구간의 합을 구하는 배열을 만드는 것이 중요하다

```js
arr = [1, 2, 3, 4, 5]
sumArr = [1, 3, 6, 10, 15]

//   인덱스    0  1  2   3  4
// 기본 배열   1  2  3   4  5
//  합 배열    1  3  6  10  15
```

1.  합 배열을 만드는 방법은 다음과 같다  
    `sumArr[i] = sumArr[i-1] + arr[i]`

    구간의 합을 구할때는 어떻게 해야할까?

    `sumArr[j] - sumArr[i-1] // i에서 j까지 구간 합`

2.  2차원 배열의 합 배열을 구하려면?  
    `sumArr[i][j] = sumArr[i][j-1] + sumArr[i-1][j] - sumArr[i-1][j-1] + arr[i][j]`

    2차원 배열의 구간 합을 구하는 방법?

    `result = sumArr[x2][y2] - sumArr[x1-1][y2] - sumArr[x2][y1-1] + sumArr[x1-1][y1-1] // (x1, y1)부터 (x2, y2)까지 합`

> **구간 나머지 합 구하는 방법**  
> 구간 합에서 나머지를 구하는 방법은 다음과 같다.
> 배열 `[1, 2, 3, 4, 5]`가 주어졌을때 구간 합 배열은 `[1, 3, 6, 10, 15]`이다. 만약 **3**으로 나눈 나머지가 0인 구간을 구하고 싶을 경우 구간 합 배열을 나누고 싶은 **3**으로 나눈 나머지의 배열을 구한다. 결과 다음과 같은 배열을 구할 수 있다. `[1, 0, 0, 1, 0]` 해당 배열의 같은 숫자 간의 거리가 나누었을때 0으로 떨어진다.  
> 예를 들어 `1, 1` 똑같은 값이 나온 0번째 인덱스와 3번째 인덱스에서 합 배열은 `1,10`를 합해 **3**으로 나눌 경우 나머지 0이라는 사실을 도출 할 수 있다. 결국 나머지 배열에서 0의 값을 모두 더하고 동일한 값들에 대해 **콤비네이션**을 수행하면 된다.
>
> 1. 배열의 0의 값을 모두 카운트 한다([1, 0, 0, 1, 0] 3가지)
> 2. 동일한 값들에 대해 콤비네이션을 수행한다.(0이 3개 3C2 = 3, 1이 2개 2C2 = 1)
> 3. 값들을 모두 더한다 3 + 3 + 1 = 7가지
